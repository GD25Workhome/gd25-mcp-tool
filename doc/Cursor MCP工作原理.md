# Cursor MCP 工作原理

## 什么是 MCP？

MCP（Model Context Protocol，模型上下文协议）是一种开放协议，旨在标准化应用程序如何为大型语言模型（LLM）提供上下文和工具。

## MCP 的核心作用

通过 MCP，Cursor 能够：
- 连接到外部工具和数据源
- 扩展 AI 助手的功能
- 无需手动告知 Cursor 代码之外的项目结构
- 实现更强大的功能集成

## MCP 架构

### 基本架构图

```
┌─────────────┐         ┌──────────────┐         ┌─────────────┐
│   Cursor    │ ◄─────► │  MCP 服务器   │ ◄─────► │  外部资源    │
│   (客户端)   │         │  (中间层)     │         │ (数据库/工具) │
└─────────────┘         └──────────────┘         └─────────────┘
```

### 组件说明

1. **Cursor（客户端）**
   - 用户交互界面
   - 发送请求给 MCP 服务器
   - 接收并展示结果

2. **MCP 服务器（中间层）**
   - 实现 MCP 协议
   - 连接外部资源
   - 处理请求并返回结果

3. **外部资源**
   - 数据库（MySQL、PostgreSQL、DuckDB 等）
   - 其他工具和服务（GitHub、Notion 等）

## MCP 服务器传输方式

Cursor 支持两种 MCP 服务器的传输方式：

### 1. stdio 传输方式

**特点**：
- 在本地机器上运行
- 由 Cursor 自动管理
- 通过标准输入输出（`stdout`）直接通信
- 仅限本地访问

**配置示例**：
```json
{
  "mcpServers": {
    "mysql-local": {
      "command": "npx",
      "args": [
        "@f4ww4z/mcp-mysql-server",
        "--host", "127.0.0.1"
      ]
    }
  }
}
```

**工作原理**：
1. Cursor 启动 MCP 服务器进程
2. 通过标准输入输出进行通信
3. 服务器处理请求并返回结果
4. Cursor 接收结果并展示给用户

### 2. SSE 传输方式

**特点**：
- 可在本地或远程运行
- 由用户自行管理和运行
- 通过网络通信（HTTP/SSE）
- 可在多台机器间共享

**适用场景**：
- 需要远程访问的资源
- 多用户共享的服务器
- 需要更高安全性的场景

## MCP 服务器实现

### 服务器开发要求

MCP 服务器可以使用任何能够输出到标准输出（`stdout`）或提供 HTTP 接口的语言编写，如：
- Python
- JavaScript/TypeScript
- Go
- Rust
- 其他支持标准 I/O 的语言

### 服务器职责

1. **连接管理**：建立和维护与外部资源的连接
2. **请求处理**：接收来自 Cursor 的请求
3. **协议实现**：遵循 MCP 协议规范
4. **结果返回**：将处理结果返回给 Cursor

## 工作流程示例（数据库查询）

### 完整流程

```
1. 用户在 Cursor 中请求查询数据库
   ↓
2. Cursor 通过 MCP 协议发送请求到 MCP 服务器
   ↓
3. MCP 服务器接收请求，解析 SQL 查询
   ↓
4. MCP 服务器连接数据库（MySQL/PostgreSQL/DuckDB）
   ↓
5. MCP 服务器执行 SQL 查询
   ↓
6. MCP 服务器获取查询结果
   ↓
7. MCP 服务器将结果格式化为 MCP 协议格式
   ↓
8. MCP 服务器通过 stdio/SSE 返回结果给 Cursor
   ↓
9. Cursor 接收结果并展示给用户
```

### 实际示例：查询 MySQL 数据库

**用户请求**：
```
"查询 users 表中的所有用户"
```

**Cursor 处理**：
1. 识别需要数据库查询
2. 调用配置的 MySQL MCP 服务器
3. 发送查询请求

**MCP 服务器处理**：
1. 接收请求：`{"action": "query", "sql": "SELECT * FROM users"}`
2. 连接 MySQL 数据库
3. 执行 SQL：`SELECT * FROM users`
4. 获取结果集
5. 格式化结果

**返回结果**：
```json
{
  "status": "success",
  "data": [
    {"id": 1, "name": "张三", "email": "zhangsan@example.com"},
    {"id": 2, "name": "李四", "email": "lisi@example.com"}
  ]
}
```

**Cursor 展示**：
- 以表格或文本形式展示查询结果
- 用户可以直接看到数据

## 为什么需要 MCP 服务器？

### 1. 解耦设计

- **Cursor 不需要了解具体数据库**：Cursor 只需要知道如何与 MCP 服务器通信
- **数据库细节封装在服务器中**：连接字符串、驱动、协议等都在服务器内部处理
- **易于扩展**：添加新的数据库支持只需要开发新的 MCP 服务器

### 2. 安全性

- **凭证管理**：数据库密码等敏感信息只在 MCP 服务器配置中，不会暴露给 Cursor 核心
- **权限控制**：可以在 MCP 服务器层面实现权限控制
- **隔离性**：MCP 服务器作为独立进程运行，即使崩溃也不会影响 Cursor

### 3. 灵活性

- **多语言支持**：可以用任何语言实现 MCP 服务器
- **自定义逻辑**：可以在服务器中添加自定义的业务逻辑
- **资源管理**：服务器可以管理连接池、缓存等资源

## npm 包的作用

### 为什么需要安装 npm 包？

以 `@bytebase/dbhub` 为例：

```bash
npm install -g @bytebase/dbhub@0.11.2
```

**这个命令的作用**：
1. **下载 MCP 服务器程序**：`@bytebase/dbhub` 就是一个实现了 MCP 协议的 Node.js 程序
2. **安装到系统路径**：`-g` 参数使其全局可访问
3. **提供可执行文件**：安装后可以通过 `npx` 或直接命令调用

### npx 的作用

在配置中看到：
```json
"command": "npx",
"args": ["-y", "@bytebase/dbhub", ...]
```

**npx 的作用**：
- **执行 npm 包**：`npx` 可以执行已安装的 npm 包中的可执行文件
- **自动下载**：如果包未安装，`npx` 可以临时下载并执行（`-y` 参数表示自动确认）
- **路径解析**：自动找到包的安装位置并执行

### 完整调用链

```
Cursor 配置
  ↓
调用: npx @bytebase/dbhub --dsn "postgres://..."
  ↓
npx 查找全局安装的包
  ↓
执行包中的 MCP 服务器程序
  ↓
MCP 服务器启动，监听 stdio
  ↓
Cursor 通过 stdio 与服务器通信
  ↓
服务器处理请求并返回结果
```

## MCP 协议特点

### 1. 标准化

- **统一接口**：所有 MCP 服务器都遵循相同的协议
- **易于集成**：Cursor 可以用相同的方式与不同的服务器通信
- **可扩展性**：协议设计支持未来扩展

### 2. 双向通信

- **请求-响应模式**：Cursor 发送请求，服务器返回响应
- **推送支持**：服务器也可以主动推送信息给 Cursor（如数据变更通知）

### 3. 类型安全

- **结构化数据**：使用 JSON 等结构化格式传输数据
- **类型定义**：协议定义了清晰的数据类型和格式

## 实际应用场景

### 1. 数据库查询

- 在开发过程中查询数据库验证数据
- 分析项目相关的数据
- 验证数据操作的正确性

### 2. 代码生成

- 根据数据库结构生成代码
- 生成 SQL 查询语句
- 生成数据模型类

### 3. 数据验证

- 验证 SQL 语句的正确性
- 检查数据完整性
- 测试数据库操作

### 4. 开发辅助

- 快速查看表结构
- 执行测试数据插入
- 清理测试数据

## 总结

MCP 的工作原理可以概括为：

1. **协议层**：定义了 Cursor 和外部资源之间的通信标准
2. **服务器层**：实现了协议的具体功能，连接外部资源
3. **客户端层**：Cursor 作为客户端，通过协议与服务器通信
4. **资源层**：实际的数据库、工具等外部资源

这种设计使得 Cursor 可以灵活地扩展功能，而无需修改核心代码，同时保持了良好的安全性和可维护性。



