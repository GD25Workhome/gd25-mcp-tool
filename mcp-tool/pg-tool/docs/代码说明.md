# 代码结构说明

本文档详细解释 pg-tool 项目中每个文件的作用和代码逻辑。

## 项目文件结构

```
pg-tool/
├── server.py                    # MCP 服务器主文件（入口点）
├── database.py                  # 数据库连接和查询逻辑
├── models.py                    # Pydantic 数据模型定义
├── requirements.txt             # Python 依赖列表
├── cursor-config.json.example   # Cursor 配置示例
├── README.md                    # 项目概述
└── docs/                        # 文档目录
    ├── spec.md                  # 项目功能规范
    ├── 开发计划.md              # 详细的开发步骤和概念说明
    ├── 使用说明.md              # 安装和使用指南
    └── 代码说明.md              # 本文件：代码结构说明
```

## 核心文件详解

### 1. server.py - MCP 服务器主文件

**作用：** 这是 MCP 服务器的入口点，负责与 Cursor 通信。

**关键组件：**

#### 1.1 服务器初始化
```python
app = Server("postgres-mcp-server")
```
- 创建 MCP 服务器实例
- `"postgres-mcp-server"` 是服务器名称，会在 Cursor 中显示

#### 1.2 工具注册（@app.list_tools）
- **作用**：告诉 Cursor 这个服务器提供哪些工具
- **返回**：工具列表，每个工具包含名称、描述和输入参数定义
- **我们的工具**：`query` - 执行 SQL 查询

**为什么需要这个：**
- Cursor 需要知道服务器能做什么
- 工具定义包含输入参数的 schema，确保类型安全

#### 1.3 工具调用处理（@app.call_tool）
- **作用**：当 Cursor 调用工具时，执行实际的逻辑
- **流程**：
  1. 接收工具名称和参数
  2. 验证参数（使用 Pydantic 模型）
  3. 调用数据库管理器执行查询
  4. 返回结果给 Cursor

**为什么需要这个：**
- 这是实际执行操作的地方
- 参数验证确保输入安全
- 错误处理提供清晰的错误信息

#### 1.4 资源列表（@app.list_resources）
- **作用**：告诉 Cursor 这个服务器提供哪些资源
- **返回**：资源列表，每个资源有 URI、名称、描述
- **我们的资源**：每个数据库表作为一个资源（`table://schema/table`）

**为什么需要这个：**
- Cursor 需要知道可以读取哪些资源
- 资源 URI 用于标识和访问资源

#### 1.5 资源读取（@app.read_resource）
- **作用**：当 Cursor 请求读取资源时，返回资源内容
- **流程**：
  1. 解析资源 URI（如 `table://public/users`）
  2. 调用数据库管理器获取表结构
  3. 返回 JSON 格式的表结构信息

**为什么需要这个：**
- 这是实际提供数据的地方
- 表结构信息作为上下文帮助 Cursor 生成更好的查询

#### 1.6 主函数（main）
- **作用**：启动服务器
- **流程**：
  1. 建立数据库连接
  2. 启动 stdio 服务器
  3. 开始监听来自 Cursor 的请求

**stdio 说明：**
- stdio = Standard Input/Output（标准输入/输出）
- Cursor 通过标准输入发送 JSON-RPC 请求
- 服务器通过标准输出返回 JSON-RPC 响应
- 这是最简单的本地通信方式，无需网络配置

### 2. database.py - 数据库管理器

**作用：** 封装所有数据库操作，提供简洁的接口。

**关键类：DatabaseManager**

#### 2.1 初始化（__init__）
- 保存数据库连接字符串
- 检查是否允许写操作（从环境变量读取）

#### 2.2 连接管理（connect/close）
- `connect()`: 建立 PostgreSQL 连接
- `close()`: 关闭连接，释放资源
- 使用 `psycopg2` 库进行连接

#### 2.3 SQL 安全性检查（_is_write_operation）
- **作用**：判断 SQL 语句是否为写操作
- **方法**：检查 SQL 的第一个关键字
- **写操作关键字**：INSERT, UPDATE, DELETE, DROP, CREATE, ALTER 等
- **只读操作**：SELECT, SHOW, DESCRIBE 等

**为什么需要这个：**
- 防止意外修改数据
- 默认只允许 SELECT 查询，更安全
- 写操作需要明确启用

#### 2.4 执行查询（execute_query）
- **作用**：执行 SQL 查询并返回结果
- **流程**：
  1. 检查是否为写操作（如果是且未启用，抛出错误）
  2. 使用 `RealDictCursor` 执行查询（返回字典格式）
  3. 提取列名和行数据
  4. 封装为 `QueryResult` 对象返回

**RealDictCursor 说明：**
- 普通 cursor 返回元组：`(1, 'Alice', 'alice@example.com')`
- RealDictCursor 返回字典：`{'id': 1, 'name': 'Alice', 'email': 'alice@example.com'}`
- 字典格式更容易转换为 JSON，也更易读

#### 2.5 获取表结构（get_table_schema）
- **作用**：查询 PostgreSQL 系统表获取表结构信息
- **数据来源**：`information_schema` 系统视图
- **返回信息**：
  - 列名、数据类型、是否可空、默认值
  - 主键信息

**information_schema 说明：**
- PostgreSQL 提供的标准系统视图
- 包含数据库的元数据（表、列、约束等）
- 跨数据库标准，便于移植

#### 2.6 列出所有表（list_tables）
- **作用**：获取数据库中所有用户表的列表
- **过滤**：排除系统表（information_schema 和 pg_catalog 模式）

### 3. models.py - 数据模型

**作用：** 使用 Pydantic 定义数据模型，确保类型安全和数据验证。

**关键模型：**

#### 3.1 QueryInput
- **用途**：验证 SQL 查询工具的输入参数
- **字段**：`sql` (string) - SQL 查询语句
- **验证**：确保 sql 字段存在且为字符串

#### 3.2 QueryResult
- **用途**：封装查询结果
- **字段**：
  - `columns`: 列名列表
  - `rows`: 行数据列表（每行是字典）
  - `row_count`: 行数

#### 3.3 ColumnInfo
- **用途**：表示数据库列的信息
- **字段**：列名、数据类型、是否可空、默认值

#### 3.4 TableSchema
- **用途**：表示整个表的结构
- **字段**：模式名、表名、列列表、主键列表

#### 3.5 TableList
- **用途**：表示表列表
- **字段**：表信息列表

**为什么使用 Pydantic：**
- **类型安全**：确保数据类型正确
- **自动验证**：自动检查必填字段、类型等
- **清晰错误**：验证失败时提供详细的错误信息
- **文档生成**：可以自动生成 API 文档

## 数据流说明

### 工具调用流程

```
1. Cursor 用户请求
   ↓
2. Cursor 调用 query 工具
   ↓
3. server.py 的 call_tool 函数接收请求
   ↓
4. 使用 QueryInput 验证参数
   ↓
5. database.py 的 execute_query 执行查询
   ↓
6. 检查 SQL 安全性（只读/写操作）
   ↓
7. 执行 SQL，获取结果
   ↓
8. 封装为 QueryResult 返回
   ↓
9. 转换为 JSON 返回给 Cursor
   ↓
10. Cursor 显示结果给用户
```

### 资源读取流程

```
1. Cursor 需要表结构信息
   ↓
2. Cursor 读取 table://public/users 资源
   ↓
3. server.py 的 read_resource 函数接收请求
   ↓
4. 解析 URI，提取 schema 和 table
   ↓
5. database.py 的 get_table_schema 查询表结构
   ↓
6. 查询 information_schema 获取列信息
   ↓
7. 查询主键信息
   ↓
8. 封装为 TableSchema 返回
   ↓
9. 转换为 JSON 返回给 Cursor
   ↓
10. Cursor 使用表结构信息生成更好的查询
```

## 关键设计决策

### 1. 为什么默认只读？
- **安全性**：防止意外修改或删除数据
- **最佳实践**：大多数场景只需要查询
- **可控性**：写操作需要明确启用

### 2. 为什么使用 stdio？
- **简单**：无需网络配置
- **安全**：本地通信，无网络暴露
- **适合开发**：快速迭代和测试

### 3. 为什么分离 database.py？
- **关注点分离**：服务器逻辑 vs 数据库逻辑
- **可测试性**：可以单独测试数据库操作
- **可维护性**：代码更清晰，易于修改

### 4. 为什么使用 Pydantic？
- **类型安全**：Python 的类型提示 + 运行时验证
- **自动文档**：可以生成 API 文档
- **错误信息**：清晰的验证错误信息

## 扩展建议

### 1. 添加提示（Prompts）
- 预定义的查询模板
- 最佳实践建议
- 示例查询

### 2. 添加日志
- 记录所有查询
- 性能监控
- 错误追踪

### 3. 添加缓存
- 缓存表结构信息
- 减少数据库查询

### 4. 支持 HTTP 传输
- 团队共享访问
- 集中式部署
- 更好的安全性

## 总结

这个项目展示了如何构建一个完整的 MCP 服务器：
1. **服务器层**（server.py）：处理 MCP 协议通信
2. **业务逻辑层**（database.py）：实现实际功能
3. **数据模型层**（models.py）：确保数据正确性

每一层都有明确的职责，代码结构清晰，易于理解和维护。

